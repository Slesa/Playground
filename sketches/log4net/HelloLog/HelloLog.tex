\documentclass[a4paper]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[ngerman]{babel}

\usepackage{url}

\usepackage{listings}
\usepackage{color}
\definecolor{darkgray}{rgb}{0.95,0.95,0.95}

\lstset{language=C++, tabsize=2, backgroundcolor=\color{darkgray}, showstringspaces=false, basicstyle=\footnotesize, breaklines=true}


\begin{document}
\author{Jörg Preiß}
\title{Log4net}
\maketitle
\tableofcontents

\section{Requirements}

\subsection{Log4net bereitstellen}
Per NuGet steht unter "`Add library package reference"' das Paket log4net bereit. Alternativ kann man unter \url{http://logging.apache.org/log4net/download.html}
ein entsprechendes Paket herunterladen.


\subsection{Programm vorbereiten}
Es gibt zwei Möglichkeiten, ein Programm zur Zusammenarbeit mit Log4net zu bewegen: entweder per Eintrag in der AssemblyInfo.cs oder programmatisch.


\subsubsection{Per AssemblyInfo}
In der Datei AssemblyInfo.cs ist die Zeile einzufügen:

\begin{lstlisting}
[assembly: log4net.Config.XmlConfigurator()]
\end{lstlisting}

Falls es sich um ein Web-Projekt handelt, oder man aus einem anderen Grund die Konfigurationsdatei ändern möchte, kann man per optionalem Parameter eine andere
Konfigurationsdatei angeben:

\begin{lstlisting}
[assembly: log4net.Config.XmlConfigurator(ConfigFile = "App.config")]
\end{lstlisting}

Ein weiterer Parameter namens \emph{Watch} gibt an, ob die Konfigurationsdatei auf Änderungen hin überwacht werden soll:

\begin{lstlisting}
[assembly: log4net.Config.XmlConfigurator(Watch=true)]
\end{lstlisting}


\subsubsection{Programmatisch}
Für das einfache Konfigurieren von Log4net genügt die Zeile

\begin{lstlisting}
log4net.Config.XmlConfigurator.Configure();
\end{lstlisting}

Das Ändern der Konfigurationsdatei kann zB erfolgen durch
\begin{lstlisting}
log4net.Config.XmlConfigurator.Configure(new FileInfo("log4net.config"));
\end{lstlisting}

Das Überwachen der Konfigurationsdatei wird erreicht mittels

\begin{lstlisting}
log4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo("log4net.config"));
\end{lstlisting}

in diesem Fall muss allerdings zwingend eine Konfigurationsdatei angegeben werden.


\section{Logs ausgeben}
Zur Ausgabe von Logs genügt es, vom LogManager von Log4net ein Handle für die aktuelle Klasse anzufordern und die Nachricht abzusetzen:

\begin{lstlisting}
class Foo
{
	static readonly ILog Log = LogManager.GetLogger(typeof(Foo));

	public Foo()
  {
  	Log.Info("c'tor of Foo");
	}
}
\end{lstlisting}

Je nach globalen Konfiguration der Logausgabe von Log4net und eventuell vorgenommenen gesonderten Einstellungen der Klasse, in diesem 
Falle Foo, wird die Nachricht ausgegeben oder unterdrückt.\\
Zu den einfachen Textausgabe-Funktionen - \emph{Debug}, \emph{Info}, \emph{Warn}, \emph{Error} - gibt es eine korrespondierende Funktion 
zur formatierten Ausgabe von Text - \emph{DebugFormat}, \emph{InfoFormat}, \emph{WarnFormat}, \emph{ErrorFormat}:

\begin{lstlisting}
  	Log.InfoFormat("Foo called at {0}", DateTime.Now);
\end{lstlisting}

\section{Logs konfigurieren}
Nachdem wir das Programm auf das Loggen vorbereitet und sogar schon erste Log-Ausgaben in die Klassen eingefügt haben, erhalten wir 
vorerst keine Ausgaben - es ist kein Log-Mechanismus konfiguriert, der die Ausgabe vornimmt.\\
Um wenigstens zu sehen, was eventuell schief läuft bei der Konfiguration von Log4net, können wir innerhalb der \textbf{App.config} (oder der jeweils
angegebenen Konfigurationsdatei für Log4net) das interne Debugging anschalten:

\begin{lstlisting}
<configuration>
  <appSettings>
    <add key="log4net.Internal.Debug" value="true" />
  </appSettings>
</configuration>
\end{lstlisting}

\subsection{Globale Einstellungen}
Die Konfiguration der Log-Mechanismen erfolgt mittels eines SectionHandlers von Log4net. Wir legen eine neue Sektion an und setzen
den Default-Level erst einmal auf \emph{Warn}:

\begin{lstlisting}
<configuration>
  <configSections>
    <section name="log4net" 
      type="log4net.Config.Log4NetConfigurationSectionHandler, log4net"/>
  </configSections>
  <log4net>
    <root>
      <level value="WARN"/>
    </root>
  </log4net>
</configuration>
\end{lstlisting}

Damit ist erst einmal sichergestellt, daß Log4net konfiguriert wird und alle Nachrichten mit den Stufen \emph{Warn} oder \emph{Error} 
ausgegeben werden. Aber wohin?\\

\subsubsection{Konsolenausgabe}
Die erste Möglichkeit wäre die Ausgabe auf die Konsole. Hierfür müssen wir einen Appender einrichten und Log4net anweisen ihn zu 
benutzen:

\begin{lstlisting}
...
  <log4net>
    <root>
      <level value="WARN"/>
      <appender-ref ref="Console"/>
    </root>
    <appender name="Console" type="log4net.Appender.ConsoleAppender">
      <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%date [%thread] %-5level %logger [%ndc] &lt;%property{auth}&gt; - %message%newline" />
      </layout>
    </appender>
  </log4net>
...
\end{lstlisting}

Wichtig hierbei ist die Definition eines Ausgabe-Layouts, sonst beschwert sich Log4net. Alternativ kann auch das Layout auch mittels

\begin{lstlisting}
<layout type="log4net.Layout.SimpleLayout" />
\end{lstlisting}

erfolgen. Ab jetzt sollte eine Ausgabe der Log-Nachrichten in der Konsole erscheinen! Wohlgemerkt auf der Konsole, nicht im 
Debug-Fenster von Visual Studio.

\subsubsection{Farbige Konsolenausgabe}
Wer es lieber bunt mag, kann auch die kolorierte Ausgabe des Konsolenappenders benutzen. Allerdings muß hierfür auch das Farbmapping
angegeben werden:

\begin{lstlisting}
...
  <log4net>
    <root>
      <level value="WARN"/>
      <appender-ref ref="Colored"/>
    </root>
    <appender name="Colored" type="log4net.Appender.ColoredConsoleAppender">
      <mapping>
        <level value="FATAL" />
        <foreColor value="Red" />
        <backColor value="White" />
      </mapping>
      <mapping>
        <level value="ERROR" />
        <foreColor value="Red, HighIntensity" />
      </mapping>
      <mapping>
        <level value="WARN" />
        <foreColor value="Yellow" />
      </mapping>
      <mapping>
        <level value="INFO" />
        <foreColor value="Cyan" />
      </mapping>
      <mapping>
        <level value="DEBUG" />
        <foreColor value="Green" />
      </mapping>
      <layout type="log4net.Layout.SimpleLayout" />
    </appender>
  </log4net>
...
\end{lstlisting}

\subsubsection{Ausgabe im Debug-Fenster}
Wie erwähnt, erscheint die Konsolenausgabe nicht im Debugfenster von Visual Studio. Hierfür existiert ein eigener Appender:

\begin{lstlisting}
...
  <log4net>
    <root>
      <level value="WARN"/>
      <appender-ref ref="Debug"/>
    </root>
    <appender name="Debug" type="log4net.Appender.DebugAppender">
      <immediateFlush value="true" />
      <layout type="log4net.Layout.SimpleLayout" />
    </appender>
  </log4net>
...
\end{lstlisting}


\subsubsection{Ausgabe in Datei}
Die Ausgabe in eine Datei kann ganz einfach erfolgen über

\begin{lstlisting}
...
  <log4net>
    <root>
      <level value="WARN"/>
      <appender-ref ref="File"/>
    </root>
    <appender name="File" type="log4net.Appender.FileAppender">
	    <file value="log/myfile.txt" />   
  	  <appendToFile value="true" />   
    	<encoding value="utf-8" />   
    	<layout type="log4net.Layout.SimpleLayout" />   
    </appender>
  </log4net>
...
\end{lstlisting}

Das Unterverzeichnis "`log"' wird hierbei angelegt falls es nicht existiert.\\
Soll die Log-Datei hierbei eine gewisse Größe nicht überschreiten, oder soll der Dateiname in Abhängigkeit des Datums 
gebildet werden, empfiehlt sich der Einsatz des RollingFileAppenders:

\begin{lstlisting}
...
  <log4net>
    <root>
      <level value="WARN"/>
      <appender-ref ref="RollSize"/>
      <appender-ref ref="RollDate"/>
    </root>
    <appender name="RollSize" type="log4net.Appender.RollingFileAppender">
      <file value="log/SizeLog.txt" />
      <appendToFile value="true" />
      <rollingStyle value="size" />
      <maxSizeRollBackups value="10" />
      <maximumFileSize value="1MB" />
      <layout type="log4net.Layout.SimpleLayout" />
    </appender>
    <appender name="RollDate" type="log4net.Appender.RollingFileAppender">
      <file value="log/DateLog.txt" />
      <appendToFile value="true" />
      <rollingStyle value="date" />
      <layout type="log4net.Layout.SimpleLayout" />
    </appender>
  </log4net>
...
\end{lstlisting}

\section{Epilog}
Es existieren noch weit mehr Appender als hier angegeben, zB Ausgabe auf Twitter, MongoDB, etc \dots
Hier noch eine kleine Übersicht der mitgelieferten Appender:\\

		\begin{tabular}{l|l}
			log4net.Appender\@. & Beschreibung\\
			\hline AdoNetAppender & Ausgabe in Datenbank\\
			AnsiColorTerminalAppender & Ausgabe auf Terminal mittels ANSI-Farbsequenzen\\
			AspNetTraceAppender & Ausgabe in ASP.NET Trace-Kontext\\
			BufferingForwardingAppender & Puffert Einträge und leitet sie weiter\\
			ColoredConsoleAppender & Farbige Ausgabe in Konsole\\
			ConsoleAppender & Ausgabe in Konsole\\
			DebugAppender & Ausgabe in das Debug-Fenster\\
			EventLogAppender & Ausgabe in das Event-Log\\
			ForwardingAppender & Weiterleitung der Einträge\\
			FileAppender & Ausgabe in Datei\\
			LocalSyslogAppender & Ausgabe in das Syslog-System\\
			MemoryAppender\\
			NetSendAppender\\
			OutputDebugStringAppender\\
			RemoteSyslogAppender\\
			RemotingAppender\\
			RollingFileAppender\\
			SmtpAppender\\
			SmtpPickupDirAppender\\
			TelnetAppender & Ausgabe auf Telnet-Host, mit dem man sich verbinden kann\\
			TraceAppender & Ausgabe in das Trace-System\\
			UdpAppender\\
		\end{tabular}
\\
(Quelle {\url{http://www.beefycode.com/post/Log4Net-Tutorial-pt-3-Appenders.aspx})}\\

\end{document}
